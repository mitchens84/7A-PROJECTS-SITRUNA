import React, { useState, useEffect } from 'react';
import { Link, useLocation } from 'react-router-dom';
import * as AppRoutes from '../../appRoutes'; // New import
import staticTocData from '../../toc-static-data.json'; // Generated by script
import usePersistentState from '../../hooks/usePersistentState';
import '../../assets/styles.css'; // Ensure styles are imported

interface CollapsibleTOCProps {}

const CollapsibleTOC: React.FC<CollapsibleTOCProps> = () => {
  const [tocItems, setTocItems] = useState<AppRoutes.TOCItem[]>([]); // Changed TOCItem to AppRoutes.TOCItem
  const [expandedItems, setExpandedItems] = usePersistentState<Record<string, boolean>>(
    'tocExpandedState',
    {},
    'localStorage'
  );
  const location = useLocation();

  useEffect(() => {
    // Combine React app routes and static routes
    const combinedRoutes: AppRoutes.TOCItem[] = [ // Changed TOCItem to AppRoutes.TOCItem
      ...AppRoutes.reactAppRoutes, // Changed reactAppRoutes to AppRoutes.reactAppRoutes
      ...(staticTocData as AppRoutes.TOCItem[]), // Changed TOCItem to AppRoutes.TOCItem
    ];
    setTocItems(combinedRoutes);
  }, []);

  const toggleItem = (id: string) => {
    setExpandedItems(prev => ({ ...prev, [id]: !prev[id] }));
  };

  const isActive = (path: string) => {
    // For static paths, ensure they are correctly matched against location.pathname
    // The static paths in toc-static-data.json already include the base Href.
    // location.pathname will also include the base Href when running with `npm run dev`
    // if vite.config.ts base is correctly set.
    // For GitHub Pages, location.pathname will be like /REPO_NAME/actual/path
    // and static paths will be /REPO_NAME/EXPRESS/site/index.html
    return location.pathname === path || location.pathname === `${path}/`;
  };
  
  const renderTocItem = (item: AppRoutes.TOCItem, level: number = 0): JSX.Element => { // Changed TOCItem to AppRoutes.TOCItem
    const isExpanded = expandedItems[item.id] ?? item.isInitiallyExpanded ?? false;
    const hasChildren = item.children && item.children.length > 0;

    // Determine the link target based on type
    let linkPath: string;
    if (item.type === 'static') {
      // Static paths from toc-static-data.json are already absolute (including base)
      linkPath = item.path;
    } else {
      // React paths are relative to the base
      linkPath = item.path;
    }
    
    // console.log(`Rendering item: ${item.title}, path: ${item.path}, type: ${item.type}, calculated linkPath: ${linkPath}, active: ${isActive(linkPath)}`);


    return (
      <li key={item.id} className={`toc-item level-${level} ${isActive(linkPath) ? 'active' : ''}`}>
        <div className="toc-entry">
          {hasChildren && (
            <button onClick={() => toggleItem(item.id)} className="toggle-button" aria-label={isExpanded ? 'Collapse' : 'Expand'}>
              {isExpanded ? '▼' : '▶'}
            </button>
          )}
          {item.type === 'react' ? (
            <Link to={linkPath}>{item.title}</Link>
          ) : (
            // For static links, we use a standard <a> tag
            // Ensure the path is correctly formed for deployment context
            <a href={linkPath}>{item.title}</a>
          )}
        </div>
        {hasChildren && isExpanded && (
          <ul className="toc-list nested">
            {item.children?.map(child => renderTocItem(child, level + 1))}
          </ul>
        )}
      </li>
    );
  };

  if (tocItems.length === 0) {
    return <nav className="collapsible-toc">Loading ToC...</nav>;
  }

  return (
    <nav className="collapsible-toc">
      <h3>Table of Contents</h3>
      <ul className="toc-list">
        {tocItems.map(item => renderTocItem(item))}
      </ul>
    </nav>
  );
};

export default CollapsibleTOC;
