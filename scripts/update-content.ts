import fs from 'fs';
import path from 'path';
import { pathToFileURL, fileURLToPath } from 'url';

// Resolve __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ModuleConfig {
  id: string;
  title: string;
  path: string;
  type: 'iframe' | 'react-component';
  entryPoint: string;
  description?: string;
  category?: string; // Added category property for organizing content
}

// Find config files in module directories
async function findDirConfigs(contentDir: string): Promise<ModuleConfig[]> {
  const modules: ModuleConfig[] = [];
  const dirs = fs.readdirSync(contentDir, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name);

  for (const dir of dirs) {
    const configPath = path.join(contentDir, dir, 'module.config.ts');
    if (fs.existsSync(configPath)) {
      const moduleUrl = pathToFileURL(configPath).toString();
      const mod = await import(moduleUrl);
      modules.push(mod.default as ModuleConfig);
    }
  }
  
  return modules;
}

// Find standalone config files in content directory
async function findStandaloneConfigs(contentDir: string): Promise<ModuleConfig[]> {
  const modules: ModuleConfig[] = [];
  const files = fs.readdirSync(contentDir, { withFileTypes: true })
    .filter(f => f.isFile() && f.name.endsWith('.config.ts'))
    .map(f => f.name);

  for (const file of files) {
    const configPath = path.join(contentDir, file);
    const moduleUrl = pathToFileURL(configPath).toString();
    
    try {
      const mod = await import(moduleUrl);
      
      // Make sure mod.default exists before trying to modify it
      if (mod.default) {
        const moduleConfig = { ...mod.default } as ModuleConfig;
        // Add a custom property to mark this as standalone
        (moduleConfig as any).isStandalone = true;
        modules.push(moduleConfig);
      } else {
        console.warn(`Warning: No default export found in ${file}`);
      }
    } catch (error) {
      console.error(`Error importing ${file}:`, error);
    }
  }
  
  return modules;
}

async function main() {
  const contentDir = path.resolve(__dirname, '../content');
  const modules: ModuleConfig[] = [];
  
  // Collect modules from directories with module.config.ts
  const dirModules = await findDirConfigs(contentDir);
  modules.push(...dirModules);
  
  // Collect modules from standalone *.config.ts files
  const standaloneModules = await findStandaloneConfigs(contentDir);
  modules.push(...standaloneModules);

  const lines: string[] = [];
  lines.push('// THIS FILE IS AUTO-GENERATED BY scripts/update-content.ts. DO NOT EDIT.');
  lines.push("import React from 'react';");
  lines.push('');
  lines.push('export interface ContentModule {');
  lines.push('  id: string;');
  lines.push("  title: string;");
  lines.push("  path: string;");
  lines.push("  type: 'iframe' | 'react-component';");
  lines.push("  entryPoint: string;");
  lines.push('  description?: string;');
  lines.push('  component?: React.LazyExoticComponent<React.ComponentType<any>>;');
  lines.push('');
  lines.push('export const contentModules: ContentModule[] = [');

  for (const mod of modules) {
    lines.push('  {');
    lines.push(`    id: "${mod.id}",`);
    lines.push(`    title: "${mod.title}",`);
    lines.push(`    path: "${mod.path}",`);
    lines.push(`    type: "${mod.type}",`);
    // Static assets are served at /<moduleId>/<entryPath>
    const entry = mod.entryPoint.replace(/^\.\//, '');
    
    // For standalone modules, the entry point is directly in the content folder
    const isStandaloneModule = (mod as any).isStandalone === true;
    
    if (isStandaloneModule) {
      lines.push(`    entryPoint: "/${entry}",`);
    } else {
      lines.push(`    entryPoint: "/${mod.id}/${entry}",`);
    }

    if (mod.type === 'react-component') {
      // Remove .tsx, .ts, .jsx, .js extensions from the import path
      const importPath = isStandaloneModule 
        ? `../content/${entry.replace(/\.(tsx|ts|jsx|js)$/, '')}`
        : `../content/${mod.id}/${entry.replace(/\.(tsx|ts|jsx|js)$/, '')}`;
      lines.push(`    component: React.lazy(() => import("${importPath}")),`);
    }
    lines.push('  },');
  }

  lines.push('];');
  lines.push('');
  lines.push('export const getModuleByPath = (path: string) => contentModules.find(m => m.path === path);');

  const output = lines.join('\n');
  const outPath = path.resolve(__dirname, '../src/content-registry.ts');
  fs.writeFileSync(outPath, output, 'utf-8');
  console.log(`Generated ${outPath} with ${modules.length} modules.`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
