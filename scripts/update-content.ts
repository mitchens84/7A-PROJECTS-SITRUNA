import fs from 'fs';
import path from 'path';
import { pathToFileURL, fileURLToPath } from 'url';

// Resolve __dirname in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ModuleConfig {
  id: string;
  title: string;
  path: string;
  type: 'iframe' | 'react-component';
  entryPoint: string;
  description?: string;
  category?: string; // Added category property for organizing content
}

// Find config files in module directories
async function findDirConfigs(contentDir: string): Promise<ModuleConfig[]> {
  const modules: ModuleConfig[] = [];
  const dirs = fs.readdirSync(contentDir, { withFileTypes: true })
    .filter(d => d.isDirectory())
    .map(d => d.name);

  for (const dir of dirs) {
    const configPath = path.join(contentDir, dir, 'module.config.ts');
    if (fs.existsSync(configPath)) {
      console.log(`[update-content] Found config for directory module: ${configPath}`);
      const moduleUrl = pathToFileURL(configPath).toString();
      try {
        const modImport = await import(moduleUrl);
        if (modImport.default) {
          const moduleConfig = { ...modImport.default } as ModuleConfig;
          if (!moduleConfig.id || !moduleConfig.title || !moduleConfig.path || !moduleConfig.type || !moduleConfig.entryPoint) {
            console.warn(`[update-content] Warning: Module config from ${configPath} is missing one or more required fields (id, title, path, type, entryPoint). Skipping.`);
            continue;
          }
          console.log(`[update-content] Successfully imported directory module config: ${moduleConfig.id}`);
          modules.push(moduleConfig);
        } else {
          console.warn(`[update-content] Warning: No default export found in directory module config ${configPath}. Skipping.`);
        }
      } catch (error) {
        console.error(`[update-content] Error importing directory module config ${configPath}:`, error);
      }
    }
  }
  return modules; // Added missing return statement
}

// Find standalone config files in content directory
async function findStandaloneConfigs(contentDir: string): Promise<ModuleConfig[]> {
  const modules: ModuleConfig[] = [];
  const files = fs.readdirSync(contentDir, { withFileTypes: true })
    .filter(f => f.isFile() && f.name.endsWith('.config.ts'))
    .map(f => f.name);

  for (const file of files) {
    const configPath = path.join(contentDir, file);
    console.log(`[update-content] Found standalone config: ${configPath}`);
    const moduleUrl = pathToFileURL(configPath).toString();
    
    try {
      const modImport = await import(moduleUrl);
      
      if (modImport.default) {
        const moduleConfig = { ...modImport.default } as ModuleConfig;
        if (!moduleConfig.id || !moduleConfig.title || !moduleConfig.path || !moduleConfig.type || !moduleConfig.entryPoint) {
          console.warn(`[update-content] Warning: Standalone module config from ${configPath} is missing one or more required fields (id, title, path, type, entryPoint). Skipping.`);
          continue;
        }
        (moduleConfig as any).isStandalone = true;
        console.log(`[update-content] Successfully imported standalone module config: ${moduleConfig.id}`);
        modules.push(moduleConfig);
      } else {
        console.warn(`[update-content] Warning: No default export found in standalone config ${configPath}. Skipping.`);
      }
    } catch (error) {
      console.error(`[update-content] Error importing standalone module config ${configPath}:`, error);
    }
  }
  return modules; // Added missing return statement
}

async function main() {
  const contentDir = path.resolve(__dirname, '../content');
  const modules: ModuleConfig[] = [];
  
  // Collect modules from directories with module.config.ts
  const dirModules = await findDirConfigs(contentDir);
  modules.push(...dirModules);
  
  // Collect modules from standalone *.config.ts files
  const standaloneModules = await findStandaloneConfigs(contentDir);
  modules.push(...standaloneModules);

  const registryLines: string[] = [];
  registryLines.push('// THIS FILE IS AUTO-GENERATED BY scripts/update-content.ts. DO NOT EDIT.');
  registryLines.push("import React from 'react';");
  registryLines.push('');
  registryLines.push('export interface ModuleConfig {');
  registryLines.push('  id: string;');
  registryLines.push("  title: string;");
  registryLines.push("  path: string; // URL path segment");
  registryLines.push("  type: 'react-component' | 'iframe';");
  registryLines.push("  entryPoint: string; // For React: path to component file relative to content dir (e.g., 'module-id/Component.tsx')");
  registryLines.push("                      // For iframe: path to HTML file relative to content dir (e.g., 'module-id/index.html')");
  registryLines.push('  description?: string;');
  registryLines.push('  category?: string;');
  registryLines.push('}');
  registryLines.push('');
  registryLines.push('// Configs for all modules, used by ContentRenderer to get metadata');
  registryLines.push('export const contentModulesConfig: ModuleConfig[] = [');

  for (const mod of modules) {
    registryLines.push('  {');
    registryLines.push(`    id: "${mod.id}",`);
    registryLines.push(`    title: "${mod.title}",`);
    registryLines.push(`    path: "${mod.path}",`);
    registryLines.push(`    type: "${mod.type}",`);
    // Ensure entryPoint is relative to the content directory
    // If mod.entryPoint is './Component.tsx' and it's in 'my-module', it becomes 'my-module/Component.tsx'
    // If it's a standalone config, entryPoint might be 'MyStandaloneComponent.tsx'
    const isStandaloneModule = (mod as any).isStandalone === true;
    const entry = mod.entryPoint.replace(/^\\.\\\//, ''); // remove leading ./ if present
    const finalEntryPoint = isStandaloneModule ? entry : `${mod.id}/${entry}`;
    registryLines.push(`    entryPoint: "${finalEntryPoint}",`);
    console.log(`[update-content] Processing module: ${mod.id}, type: ${mod.type}, entryPoint: ${finalEntryPoint}`); // Moved log here
    if (mod.description) registryLines.push(`    description: "${mod.description.replace(/"/g, '\\"')}",`);
    if (mod.category) registryLines.push(`    category: "${mod.category}",`);
    registryLines.push('  },');
  }
  registryLines.push('];');
  registryLines.push('');

  registryLines.push('// Pre-created lazy components for React modules');
  registryLines.push('// Key: moduleConfig.entryPoint for react-component types');
  registryLines.push('// Value: React.LazyExoticComponent');
  registryLines.push('export const moduleComponents: Record<string, React.LazyExoticComponent<React.ComponentType<any>>> = {');
  for (const mod of modules) {
    if (mod.type === 'react-component') {
      const isStandaloneModule = (mod as any).isStandalone === true;
      const entry = mod.entryPoint.replace(/^\\.\\\//, '');
      const finalEntryPoint = isStandaloneModule ? entry : `${mod.id}/${entry}`; // Used consistent finalEntryPoint for key
      const finalEntryPointForImport = isStandaloneModule ? entry : `${mod.id}/${entry}`;
      const importPath = `@content/${finalEntryPointForImport.replace(/\\.(tsx|ts|jsx|js)$/, '')}`;
      registryLines.push(`  "${finalEntryPoint}": React.lazy(() => import("${importPath}")),`);
      console.log(`[update-content]   React component: ${mod.id} (key: ${finalEntryPoint}), import path: ${importPath}`);
    }
  }
  registryLines.push('};');
  registryLines.push('');

  registryLines.push('export const getModuleByPath = (urlPath: string): ModuleConfig | undefined =>');
  registryLines.push('  contentModulesConfig.find(m => m.path === urlPath);');
  registryLines.push('');
  registryLines.push('export const getReactComponent = (entryPoint: string): React.LazyExoticComponent<React.ComponentType<any>> | undefined =>');
  registryLines.push('  moduleComponents[entryPoint];');
  registryLines.push('');
  registryLines.push('export const getIframeSrc = (moduleConfig: ModuleConfig): string => {');
  registryLines.push("  // entryPoint is already relative to content dir, e.g., 'my-module/index.html'");
  registryLines.push("  return `${import.meta.env.BASE_URL}content/${moduleConfig.entryPoint}`;");
  registryLines.push('};');

  const output = registryLines.join('\n');
  const outPath = path.resolve(__dirname, '../src/content-registry.ts');
  fs.writeFileSync(outPath, output, 'utf-8');
  console.log(`Generated ${outPath} with ${modules.length} modules.`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
});
